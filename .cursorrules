# ViralVibe SaaS - Cursor AI Rules & Vibe Coding Standards

## Project Overview
ViralVibe is a production-ready SaaS platform for viral video repurposing, competing with OpusClip and WayinVideo. The platform uses AI to analyze long-form videos, identify viral moments, and automatically generate optimized short-form clips.

## Tech Stack
- **Frontend**: Next.js 14 (App Router), TypeScript, Tailwind CSS, shadcn/ui, Remotion
- **Backend**: FastAPI, Python 3.10, SQLAlchemy, Celery, Redis
- **Database**: Supabase (PostgreSQL)
- **Video Processing**: Modal (GPU functions), WhisperX, Pyannote, FFmpeg
- **Cloud Storage**: AWS S3
- **AI/ML**: OpenAI GPT-4o, Whisper, Active Speaker Detection

## Vibe Coding Principles

### 1. Rapid Iteration
- Focus on core features first, avoid premature optimization
- Ship working code quickly, refine later
- Use framework defaults and conventions

### 2. Minimal Boilerplate
- Leverage framework features (Next.js App Router, FastAPI auto-docs)
- Use established libraries (shadcn/ui, Tailwind)
- Avoid custom abstractions unless absolutely necessary

### 3. Strict Typing
- **Python**: Use Pydantic models for all API schemas, strict type hints throughout
- **TypeScript**: Enable strict mode, no `any` types, use proper interfaces
- All function parameters and returns must be typed

### 4. Self-Healing Logic
- Implement automatic retries with exponential backoff
- Graceful degradation when services fail
- Comprehensive error handling at every layer
- User-friendly error messages

### 5. Clean Code
- Clear, descriptive naming (no abbreviations unless obvious)
- Functions should do one thing well
- Maximum function length: 50 lines
- Add comments for complex logic only
- Use early returns to reduce nesting

## Code Style Guidelines

### Python (FastAPI Backend)
```python
# Use Pydantic for validation
class VideoUploadRequest(BaseModel):
    youtube_url: HttpUrl | None = None
    title: str = Field(..., min_length=1, max_length=200)

# Async by default
async def get_video(video_id: UUID, db: AsyncSession) -> Video:
    result = await db.execute(select(Video).where(Video.id == video_id))
    return result.scalar_one_or_none()

# Error handling
@app.post("/api/videos/upload")
async def upload_video(request: VideoUploadRequest, user: User = Depends(get_current_user)):
    try:
        video = await create_video(request, user.id)
        return {"video_id": video.id, "status": video.status}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Upload failed: {e}")
        raise HTTPException(status_code=500, detail="Upload failed")
```

### TypeScript (Next.js Frontend)
```typescript
// Use proper interfaces
interface Video {
  id: string;
  title: string;
  status: VideoStatus;
  clips_count: number;
  created_at: string;
}

// Server components by default
export default async function DashboardPage() {
  const videos = await getVideos();
  return <VideoGrid videos={videos} />;
}

// Client components when needed
'use client';
export function VideoCard({ video }: { video: Video }) {
  const [isHovered, setIsHovered] = useState(false);
  // ...
}

// Custom hooks for API calls
export function useVideoStatus(videoId: string) {
  return useQuery({
    queryKey: ['video', videoId],
    queryFn: () => api.getVideo(videoId),
    refetchInterval: 3000,
  });
}
```

### File Naming Conventions
- **React Components**: PascalCase (e.g., `VideoCard.tsx`, `ClipGallery.tsx`)
- **Utilities/Hooks**: camelCase (e.g., `formatDuration.ts`, `useVideoStatus.ts`)
- **API Routes**: kebab-case (e.g., `process-video.ts`, `export-clip.ts`)
- **Python Files**: snake_case (e.g., `video_processor.py`, `celery_tasks.py`)

### Directory Structure Rules
- **Frontend**: Group by feature, not by type
  - ✅ `app/(protected)/dashboard/` 
  - ❌ `components/pages/dashboard/`
- **Backend**: Group by domain
  - ✅ `routes/videos.py`, `routes/clips.py`
  - ❌ `api/endpoints.py` (everything in one file)

## Security Best Practices
- Never commit secrets (use .env.example templates)
- Validate all user inputs with Pydantic/Zod
- Use parameterized queries (SQLAlchemy ORM)
- Implement rate limiting on all API endpoints
- Enable CORS only for specific origins
- JWT tokens with short expiry (1 hour)
- Row-level security (RLS) in Supabase

## Performance Guidelines
- Use async/await for I/O operations
- Implement pagination for list endpoints
- Index frequently queried database columns
- Use Redis for caching and session storage
- Optimize images (next/image, WebP format)
- Lazy load components when appropriate
- Use React Server Components by default

## Error Handling Strategy
1. **API Layer**: Return proper HTTP status codes with error schemas
2. **Celery Tasks**: Retry with exponential backoff, log to monitoring
3. **Frontend**: Use error boundaries, show user-friendly messages
4. **Modal Functions**: Graceful degradation, return error objects

## Testing Requirements
- Unit tests for critical business logic
- Integration tests for API endpoints
- E2E tests for core user flows
- Minimum 70% code coverage
- Run tests in CI/CD pipeline

## Documentation Standards
- API endpoints: Include docstrings with examples
- Complex algorithms: Add inline comments
- Configuration: Document all environment variables
- README: Setup guide, architecture overview, contributing guidelines

## Git Commit Messages
Follow conventional commits:
- `feat:` New feature
- `fix:` Bug fix
- `refactor:` Code refactoring
- `docs:` Documentation changes
- `test:` Test additions/updates
- `chore:` Tooling/config changes

Examples:
- `feat: add virality scoring algorithm`
- `fix: handle missing transcript data gracefully`
- `refactor: extract clip processing into separate module`

## AI Assistant Guidelines
When suggesting code:
1. Always check existing patterns in the codebase
2. Follow the tech stack exactly (no substitutions)
3. Include error handling and type hints
4. Suggest tests for new features
5. Consider edge cases and failure modes
6. Optimize for readability over cleverness
